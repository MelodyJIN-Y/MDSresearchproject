---
title: "R Notebook"
output: html_notebook
---
Rescources :
Marker gene analysis : http://bioconductor.org/books/release/OSCA/marker-detection.html
Gene set testing: http://bioconductor.org/books/release/OSCA/cell-type-annotation.html#assigning-cell-labels-from-gene-sets

Codes from:
https://bphipson.github.io/Human_Development_snRNAseq/02-ClusterFetal.html#perform_clustering 
http://combine-australia.github.io/RNAseq-R/06-rnaseq-day1.html#Differential_expression_with_limma-voom
extract data for one sample first 
```{r}
library(Seurat)
library(dplyr)
library(SingleCellExperiment)
library(scater)
pbmc.data<- readRDS("pbmc_pooled_sex.Rds")
cm<- pbmc.data@assays$RNA@counts
table(pbmc.data$individual)

#subset_ind<- c("685_686", "689_690","691_692")
#cm<- pbmc.data[, pbmc.data$individual %in% subset_ind ]@assays$RNA@counts
cm<- pbmc.data[, pbmc.data$individual == "689_690"]@assays$RNA@counts
dim(cm) # 32738  3402 (1789+1613) $32738  4907

par(mfrow=c(1,2))
libsize <- colSums(cm)
pz <- colMeans(cm==0)
numgene <- colSums(cm!=0)

par(mfrow=c(1,3))
plot(density(libsize),main="Distribution of library sizes")
#abline(v=3000,col=2)
plot(density(pz), main="Distribution of proportion of zeroes per cell")
#abline(v=0.95,col=2)
plot(density(numgene), main="Distribution of detected genes per cell")
abline(v=500,col=4, lty=3)
legend("topright",lty=2,col=4,legend="500 genes")
library(edgeR)

pbmc <- CreateSeuratObject(counts = cm,min.features = 500, min.cells = 5)
dim(pbmc) #12031  1329
dim(pbmc@assays$RNA@counts)
library(speckle)
prop <- getTransformedProps(pbmc.data$predicted.celltype.l1, pbmc.data$individual)
prop$Counts
prop$Proportions
```

```{r}
library(RColorBrewer)
library(ggplot2)
prop_df <- as.data.frame(prop$Proportions)
ggplot(prop_df, aes(x = sample,y = Freq, fill = clusters))+
geom_bar(stat="identity")+  
  xlab("individuals")+ylab("prop$Proportions")+
  theme(axis.text.x = element_text( angle=90))


barplot(prop$Proportions, col =brewer.pal(n = 8, name = "RdBu"),
        legend=names(table(pbmc.data$predicted.celltype.l1)),
        args.legend=list(x="topright", inset = c(- 0.15, 0))
        )
```

```{r}
pbmc <- SCTransform(pbmc, verbose = FALSE)
```


```{r}
pbmc <- ScaleData(pbmc, verbose = FALSE)
pbmc <- RunPCA(pbmc, npcs = 50, verbose = FALSE)
ElbowPlot(pbmc,ndims=50)
```

```{r}
VizDimLoadings(pbmc, dims = 1:4, reduction = "pca")
```


```{r}
pbmc <- FindNeighbors(pbmc, dims = 1:30)
#pbmc <- FindClusters(pbmc, resolution = c(0.8))
pbmc <- FindClusters(pbmc, resolution = c(0.8,0.9, 1, 1.1, 1.2, 1.3, 1.4))
table(Idents(pbmc))
table(pbmc$SCT_snn_res.1.4)
library(clustree)
par(mfrow=c(1,1))
z<- clustree(pbmc, prefix = "SCT_snn_res.")
pdf("cluster_tree.pdf",width=8,height=8)
z
dev.off()

```

```{r}
table(pbmc.data$predicted.celltype.l1)
```



```{r}
table(pbmc$SCT_snn_res.0.8, pbmc.data[,colnames(pbmc)]$predicted.celltype.l1)
```

```{r}
table(pbmc.data$cell_type, pbmc.data$predicted.celltype.l1)
```


```{r}

pbmc <- RunTSNE(pbmc, reduction = "pca")
DimPlot(pbmc, reduction = "tsne",label=TRUE,label.size = 6)+NoLegend()
```

```{r}

table(pbmc.data[,colnames(pbmc)]$predicted.celltype.l1)
#pbmc_new <- RenameIdents(object = pbmc, 
#                               "0" = "CD4+ KLRB1- T cell ",
#                               "1" = "CD4+ KLRB1+ T cell ",
#                               "2" = "CD8+ GNLY+ NKG7+ T cell",
#                               "3" = "CD8+ LTB+ T cell",
#                               "4" = "XCL1- NK",
#                               "5" = "CD8+ T cells",
#                               "6" = "TCL1A+ FCER2+ B cell",
#                               "7" = "Monocyte CD14+ ",
#                               "8" = "CD8+ S100B+ T cell ")
Idents(pbmc)<- pbmc.data[,colnames(pbmc)]$predicted.celltype.l1
#Idents(pbmc)<- pbmc.data$predicted.celltype.l1
table(Idents(pbmc))
DimPlot(pbmc, reduction = "tsne",label=TRUE,label.size = 6,repel = TRUE)+NoLegend()
```

# Simulation 
```{r}
library(splatter)


cm<-pbmc@assays$RNA@counts
ann.all<- readRDS("allpbmc.Rds")
numzero.genes <- rowSums(cm==0)
keep.genes <- numzero.genes < (ncol(cm)-10)
all.keep <- cm[keep.genes,]
ann.keep.all <- ann.all[keep.genes,]
cm.processed<- all.keep

selected_cells <- colnames(cm.processed[,pbmc.data[,colnames(cm.processed)]$predicted.celltype.l1 %in% c("B", "CD4 T")])
cm.processed.r<- cm.processed[, match(selected_cells, colnames(cm.processed))]
metadata <- data.frame(cell_type = pbmc.data[row.names(cm.processed.r),colnames(cm.processed.r)]$predicted.celltype.l1,
                       ind = '689_690')
ct_prop <- as.numeric(table(pbmc.data[,colnames(cm.processed.r)]$predicted.celltype.l1)/ncol(cm.processed.r))
# B       CD4 T       CD8 T        Mono          NK     other T 
# 0.051178838 0.619321449 0.128234618 0.056929270 0.136860265 0.007475561 

sce <- SingleCellExperiment(assays = as.matrix(cm.processed.r),
                            colData=metadata)
names(assays(sce))<- "counts"
table(sce$cell_type)
params <- newSplatParams()
params <- setParam(params, "group.prob", ct_prop)
params <- splatEstimate(sce,params = params)

sim <- splatSimulate(params, method = "groups", nGenes = 5000, 
                     batchCells = 1000, de.prob = 0.02, group.prob = c(0.5, 0.5),
                     seed = 12202)
#comparison <- compareSCEs(list(Splat = sim, Scedata = sce))
#comparison$Plots$Variances
#true.sup.g1<- sim@rowRanges@elementMetadata$DEFacGroup1 != 1

true.sup.g1<- sim@rowRanges@elementMetadata[sim@rowRanges@elementMetadata$DEFacGroup1 != 1, "Gene"]
true.sup.g2<- sim@rowRanges@elementMetadata[sim@rowRanges@elementMetadata$DEFacGroup2 != 1, "Gene"]

sim_cm<- counts(sim)
levels(sim$Group)<- c("B", "CD4T")
logcounts.all <- lognormCounts(sim_cm,log=TRUE,prior.count=0.5) 
# permutate all.bct 

all.bct <- factor(sim$Group)
design <- model.matrix(~0+all.bct)
colnames(design)[1:(length(levels(all.bct)))] <- levels(all.bct)

mycont <- matrix(0,ncol=length(levels(all.bct)),nrow=length(levels(all.bct)))
colnames(mycont)<-levels(all.bct)
diag(mycont)<-1
mycont[upper.tri(mycont)]<- -1/(length(levels(all.bct))-1)
mycont[lower.tri(mycont)]<- -1/(length(levels(all.bct))-1)

# Fill out remaining rows with 0s
zero.rows <- matrix(0,ncol=length(levels(all.bct)),nrow=(ncol(design)-length(levels(all.bct))))
test <- rbind(mycont,zero.rows)

fit.obs <- lmFit(logcounts.all,design)
fit.contrast <- contrasts.fit(fit.obs,contrasts=test)

fit.cont.eb.obs <- eBayes(fit.contrast,trend=TRUE,robust=TRUE)

fit.cont.eb.obs$genes <- ann.keep.all

obs.modtstat<- fit.cont.eb.obs$t


names(fit.contrast)

ordinary.t<- fit.contrast$coef/ fit.contrast$stdev.unscaled / fit.contrast$sigma
obs.tstat<- ordinary.t
obs.t.pval<-pt(ordinary.t, df=fit.contrast$df.residual, lower.tail=FALSE)

obs.mod.pval<- pt(obs.modtstat, df=fit.cont.eb.obs$df.total, lower.tail=FALSE)

perm.size<- 1000
#modt.perm.array<- readRDS("modt_perm_array_ind1.Rds")
#t.perm.array<- readRDS("t_perm_array_ind1.Rds")

obs.mod.pval.adj<- cbind(p.adjust(obs.mod.pval[,1], method="BH"),
                     p.adjust(obs.mod.pval[,2], method="BH"))

obs.t.pval.adj<- cbind(p.adjust(obs.t.pval[,1], method="BH"),
                     p.adjust(obs.t.pval[,2], method="BH"))


modt.perm.array<- array(0, dim = c(dim(logcounts.all)[1], dim(design)[2], perm.size))
t.perm.array<- array(0, dim = c(dim(logcounts.all)[1], dim(design)[2], perm.size))
tic.clearlog()
tic("1000 perm total")

for (i in 1:perm.size) {
  print(i)
  # permutate the all.bct only 
  all.bct.shuffled <- sample(all.bct, replace = FALSE, size =length(all.bct))
  # to do marker analysis using Limma way
  design <- model.matrix(~0+all.bct.shuffled)
  colnames(design)[1:(length(levels(all.bct.shuffled)))] <- levels(all.bct.shuffled)
  mycont <- matrix(0,
                   ncol=length(levels(all.bct.shuffled)),
                   nrow=length(levels(all.bct.shuffled)))
  
  colnames(mycont)<-levels(all.bct.shuffled)
  diag(mycont)<-1
  mycont[upper.tri(mycont)]<- -1/(length(levels(all.bct.shuffled))-1)
  mycont[lower.tri(mycont)]<- -1/(length(levels(all.bct.shuffled))-1)
  
  # Fill out remaining rows with 0s
  zero.rows <- matrix(0,ncol=length(levels(all.bct.shuffled)),
                      nrow=(ncol(design)-length(levels(all.bct.shuffled))))
  
  test <- rbind(mycont, zero.rows)
  tic("lmFit")
  fit <- lmFit(logcounts.all,design)
  toc(log=TRUE)
  tic("contrasts.fit")
  fit.cont <- contrasts.fit(fit, contrasts=test)
  toc(log=TRUE)
  t.perm.array[,,i]<-fit.cont$coef/ fit.cont$stdev.unscaled / fit.cont$sigma
  tic("eBayes")
  fit.cont.eb <- eBayes(fit.cont,trend=TRUE,robust=TRUE)
  toc(log=TRUE)
  fit.cont$genes <- ann.keep.all
  # store the statistic for current permutation 
  modt.perm.array[,,i]<- fit.cont.eb$t
  
}
toc(log=TRUE)

# sim_perm_arrays <- tPerm(sim_cm, sim$Group)
#modt.perm.array<- sim_perm_arrays$modet.perm
#t.perm.array<- sim_perm_arrays$t.perm

modt.perm.pvals<-apply(expand.grid(x = 1:dim(logcounts.all)[1], 
                           y = 1:dim(design)[2]), 1, 
                function(r) (sum(modt.perm.array[r[1],r[2], ]> obs.modtstat[r[1],r[2]]
                                 )+1)/(perm.size+1) )

(modt.perm.pval<- matrix(modt.perm.pvals, 
                  nrow=dim(logcounts.all)[1], 
                  ncol = dim(design)[2], 
                   byrow=FALSE))
rownames(modt.perm.pval) <- row.names(fit.cont.eb.obs)
colnames(modt.perm.pval) <- colnames(fit.cont.eb.obs)

modt.perm.pval.adj<- cbind(p.adjust(modt.perm.pval[,1], method="BH"),
                     p.adjust(modt.perm.pval[,2], method="BH"))

rownames(modt.perm.pval.adj) <- row.names(fit.cont.eb.obs)
colnames(modt.perm.pval.adj) <- colnames(fit.cont.eb.obs)

##########
# t-stat
t.perm.pvals<-apply(expand.grid(x = 1:dim(logcounts.all)[1], 
                           y = 1:dim(design)[2]), 1, 
                function(r) (sum(t.perm.array[r[1],r[2], ]> obs.tstat[r[1],r[2]])+1)/(perm.size+1) )

(t.perm.pval<- matrix(t.perm.pvals, 
                  nrow=dim(logcounts.all)[1], 
                  ncol = dim(design)[2], 
                   byrow=FALSE))
rownames(t.perm.pval) <- row.names(fit.cont.eb.obs)
colnames(t.perm.pval) <- colnames(fit.cont.eb.obs)

t.perm.pval.adj<- cbind(p.adjust(t.perm.pval[,1], method="BH"),
                     p.adjust(t.perm.pval[,2], method="BH"))

rownames(t.perm.pval.adj) <- row.names(fit.cont.eb.obs)
colnames(t.perm.pval.adj) <- colnames(fit.cont.eb.obs)


for (i in 1:2){
  #pdf(paste("hist_obs.t.pval.adj_ind1",i,"pdf", sep="."))
  hist(obs.t.pval.adj[,i],
       main = paste("p-values by limma", "-", colnames(obs.t.pval)[i],"cells"), 
       xlab  ="adjusted p-values (t)",
       ylim=c(0, 1500))
  #dev.off()
}

for (i in 1:2){
  #pdf(paste("hist_t.perm.pval.adj_ind1",i,"pdf", sep="."))
  hist(t.perm.pval.adj[,i],
       main = paste("p-values by permutation", "-", colnames(obs.t.pval)[i],"cells"), 
       xlab  ="adjusted p-values (t)")
       #ylim=c(0, 1500))
  #dev.off()
}

for (i in 1:2){
  #pdf(paste("tstat_ind1_p",i,"pdf", sep="."))
  plot(t.perm.pval[, i],obs.t.pval[, i],     
       lwd=0.1, pch=".", 
       xlab =("pvalue by permutation"), 
       ylab=("pvalue by limma"), 
       main=(paste(colnames(modt.perm.pval)[i],"cells")))
  abline(a = 0,b=1, col="blue", lwd = 1.5)
  #dev.off()
  limma_upreg_genes =  row.names(obs.t.pval[which(obs.t.pval[,i]<0.05),])
  perm_up_reg_genes =  row.names(t.perm.pval[which(t.perm.pval[,i]<0.05),])
  # print(intersect(true.sup.g1, limma_upreg_genes))
  #pdf(paste("tstat_sig_ind1_p",i,"pdf", sep="."))
  plot(t.perm.pval[match(up_reg_genes, row.names(t.perm.pval)), i], 
       obs.t.pval[match(up_reg_genes, row.names(obs.t.pval)), i],
       pch="*", ylim = c(0,0.05), xlim = c(0,0.05),
       xlab =("pvalue by permutation"), 
       ylab=("pvalue by limma "), col = "orange", 
      main=(paste("significant genes for",colnames(t.perm.pval)[i],"cells")))
  abline(a = 0,b=1, col="blue", lwd = 1.5)
  #dev.off()
}

limma_upreg_genes =  row.names(obs.t.pval[which(obs.t.pval[,1]<0.05),])
perm_upreg_genes =  row.names(t.perm.pval[which(t.perm.pval[,1]<0.05),])
print(length(intersect(true.sup.g1, limma_upreg_genes)) / length(true.sup.g1))
print(length(intersect(true.sup.g1, perm_upreg_genes)) / length(true.sup.g1))

limma_upreg_genes =  row.names(obs.t.pval[which(obs.t.pval[,1]<0.05),])
perm_upreg_genes =  row.names(t.perm.pval[which(t.perm.pval[,1]<0.05),])
print(length(intersect(true.sup.g2, limma_upreg_genes)) / length(true.sup.g2))

print(length(intersect(true.sup.g2, perm_upreg_genes)) / length(true.sup.g2))

```








```{r}

# with six individuals 
removed_cells <- colnames(cm.processed[,pbmc.data[,colnames(cm.processed)]$predicted.celltype.l1 %in% c("DC", "other")])
cm.processed.r<- cm.processed[, -match(removed_cells, colnames(cm.processed))]
metadata <- data.frame(cell_type = pbmc.data[row.names(cm.processed.r),colnames(cm.processed.r)]$predicted.celltype.l1,
                       ind = '689_690')
ct_prop <- as.numeric(table(pbmc.data[,colnames(cm.processed.r)]$predicted.celltype.l1)/ncol(cm.processed.r))
# B       CD4 T       CD8 T        Mono          NK     other T 
# 0.051178838 0.619321449 0.128234618 0.056929270 0.136860265 0.007475561 

sce <- SingleCellExperiment(assays = as.matrix(cm.processed.r),
                            colData=metadata)
table(sce$cell_type)
params <- newSplatParams()
params <- setParam(params, "group.prob", ct_prop)
params <- splatEstimate(sce,params = params)
# SplatParams
sim <- splatSimulate(params, method = "groups", nGenes = 5000,
                     batchCells = 1000, dropout.type = "none", out.prob = 0, 
                     de.prob = c(0.02, 0.02, 0, 0, 0, 0), 
                     group.prob = c(900/1000, 100/1000, 0,0,0,0),
                     seed = 12202)
table(sim$Group)


true.sup.g1<- sim@rowRanges@elementMetadata[sim@rowRanges@elementMetadata$DEFacGroup1 != 1, "Gene"]
true.sup.g2<- sim@rowRanges@elementMetadata[sim@rowRanges@elementMetadata$DEFacGroup2 != 1, "Gene"]

sim_cm<- counts(sim)
levels(sim$Group)<- c("B", "CD4T", "CD8T","Mono","NK","otherT" )
#logcounts.all <- lognormCounts(sim_cm,log=TRUE,prior.count=0.5) 

all.bct <- factor(sim$Group)
design <- model.matrix(~0+all.bct)
colnames(design)[1:(length(levels(all.bct)))] <- levels(all.bct)

mycont <- matrix(0,ncol=length(levels(all.bct)),nrow=length(levels(all.bct)))
colnames(mycont)<-levels(all.bct)
diag(mycont)<-1
mycont[upper.tri(mycont)]<- -1/(length(levels(all.bct))-1)
mycont[lower.tri(mycont)]<- -1/(length(levels(all.bct))-1)

# Fill out remaining rows with 0s
zero.rows <- matrix(0,ncol=length(levels(all.bct)),nrow=(ncol(design)-length(levels(all.bct))))
test <- rbind(mycont,zero.rows)

fit.obs <- lmFit(logcounts.all,design)
fit.contrast <- contrasts.fit(fit.obs,contrasts=test)

fit.cont.eb.obs <- eBayes(fit.contrast,trend=TRUE,robust=TRUE)

fit.cont.eb.obs$genes <- ann.keep.all

obs.modtstat<- fit.cont.eb.obs$t


names(fit.contrast)

ordinary.t<- fit.contrast$coef/ fit.contrast$stdev.unscaled / fit.contrast$sigma
obs.tstat<- ordinary.t
obs.t.pval<-pt(ordinary.t, df=fit.contrast$df.residual, lower.tail=FALSE)

obs.mod.pval<- pt(obs.modtstat, df=fit.cont.eb.obs$df.total, lower.tail=FALSE)

perm.size<- 1000
#modt.perm.array<- readRDS("modt_perm_array_ind1.Rds")
#t.perm.array<- readRDS("t_perm_array_ind1.Rds")

obs.mod.pval.adj<- cbind(p.adjust(obs.mod.pval[,1], method="BH"),
                     p.adjust(obs.mod.pval[,2], method="BH"))

obs.t.pval.adj<- cbind(p.adjust(obs.t.pval[,1], method="BH"),
                     p.adjust(obs.t.pval[,2], method="BH"))
rownames(obs.t.pval.adj) <- row.names(fit.cont.eb.obs)
colnames(obs.t.pval.adj) <- colnames(fit.cont.eb.obs)

sim_perm_arrays <- tPerm(sim_cm, sim$Group)
modt.perm.array<- sim_perm_arrays$modet.perm
t.perm.array<- sim_perm_arrays$t.perm

modt.perm.pvals<-apply(expand.grid(x = 1:dim(logcounts.all)[1], 
                           y = 1:dim(design)[2]), 1, 
                function(r) (sum(modt.perm.array[r[1],r[2], ]> obs.modtstat[r[1],r[2]]
                                 )+1)/(perm.size+1) )

(modt.perm.pval<- matrix(modt.perm.pvals, 
                  nrow=dim(logcounts.all)[1], 
                  ncol = dim(design)[2], 
                   byrow=FALSE))
rownames(modt.perm.pval) <- row.names(fit.cont.eb.obs)
colnames(modt.perm.pval) <- colnames(fit.cont.eb.obs)

modt.perm.pval.adj<- cbind(p.adjust(modt.perm.pval[,1], method="BH"),
                     p.adjust(modt.perm.pval[,2], method="BH"),
                     p.adjust(modt.perm.pval[,3], method="BH"),
                     p.adjust(modt.perm.pval[,4], method="BH"),
                     p.adjust(modt.perm.pval[,5], method="BH"),
                     p.adjust(modt.perm.pval[,6], method="BH"))
rownames(modt.perm.pval.adj) <- row.names(fit.cont.eb.obs)
colnames(modt.perm.pval.adj) <- colnames(fit.cont.eb.obs)

##########
# t-stat
t.perm.pvals<-apply(expand.grid(x = 1:dim(logcounts.all)[1], 
                           y = 1:dim(design)[2]), 1, 
                function(r) (sum(t.perm.array[r[1],r[2], ]> obs.tstat[r[1],r[2]])+1)/(perm.size+1) )

(t.perm.pval<- matrix(t.perm.pvals, 
                  nrow=dim(logcounts.all)[1], 
                  ncol = dim(design)[2], 
                   byrow=FALSE))
rownames(t.perm.pval) <- row.names(fit.cont.eb.obs)
colnames(t.perm.pval) <- colnames(fit.cont.eb.obs)

t.perm.pval.adj<- cbind(p.adjust(t.perm.pval[,1], method="BH"),
                     p.adjust(t.perm.pval[,2], method="BH"))

rownames(t.perm.pval.adj) <- row.names(fit.cont.eb.obs)
colnames(t.perm.pval.adj) <- colnames(fit.cont.eb.obs)

par(mfrow=c(4, 2))
for (i in 1:2){
  #pdf(paste("hist_obs.t.pval.adj_ind1",i,"pdf", sep="."))
  hist(obs.t.pval[,i],
       main = paste("p-values by limma", "-", colnames(obs.t.pval)[i],"cells"), 
       xlab  ="p-values (t)",
       ylim=c(0, 1500))
  #dev.off()
}


for (i in 1:2){
  #pdf(paste("hist_obs.t.pval.adj_ind1",i,"pdf", sep="."))
  hist(obs.t.pval.adj[,i],
       main = paste("adjusted p-values by limma", "-", colnames(obs.t.pval)[i],"cells"), 
       xlab  ="adjusted p-values (t)",
       ylim=c(0, 1500))
  #dev.off()
}


for (i in 1:2){
  #pdf(paste("hist_t.perm.pval.adj_ind1",i,"pdf", sep="."))
  hist(t.perm.pval[,i],
       main = paste("p-values by permutation", "-", colnames(obs.t.pval)[i],"cells"), 
       xlab  ="p-values (t)")
       #ylim=c(0, 1500))
  #dev.off()
}

for (i in 1:2){
  #pdf(paste("hist_t.perm.pval.adj_ind1",i,"pdf", sep="."))
  hist(t.perm.pval.adj[,i],
       main = paste("adjusted p-values by permutation", "-", colnames(obs.t.pval)[i],"cells"), 
       xlab  ="adjusted p-values (t)")
       #ylim=c(0, 1500))
  #dev.off()
}

pdf("sim3_adjp.pdf")
par(mfrow=c(1, 2))

for (i in 1:2){
  #pdf(paste("tstat_ind1_p",i,"pdf", sep="."))
  plot(t.perm.pval.adj[, i],obs.t.pval.adj[, i],     
       lwd=0.1, pch=".", 
       xlab =("adjusted pvalue by permutation"), 
       ylab=("adjusted pvalue by limma"), 
       main=(paste(colnames(modt.perm.pval)[i],"cells")))
  abline(a = 0,b=1, col="blue", lwd = 1.5)
  #dev.off()
  limma_upreg_genes =  row.names(obs.t.pval[which(obs.t.pval[,i]<0.05),])
  perm_up_reg_genes =  row.names(t.perm.pval[which(t.perm.pval[,i]<0.05),])
  # print(intersect(true.sup.g1, limma_upreg_genes))
  #pdf(paste("tstat_sig_ind1_p",i,"pdf", sep="."))
  #plot(t.perm.pval[match(perm_up_reg_genes, row.names(t.perm.pval)), i], 
  #     obs.t.pval[match(limma_upreg_genes, row.names(obs.t.pval)), i],
  #     pch="*", ylim = c(0,0.05), xlim = c(0,0.05),
  #     xlab =("pvalue by permutation"), 
  #     ylab=("pvalue by limma "), col = "orange", 
  #    main=(paste("significant genes for",colnames(t.perm.pval)[i],"cells")))
  #abline(a = 0,b=1, col="blue", lwd = 1.5)
  #dev.off()
}
dev.off()
z<-computeSummary(obs.t.pval.adj, t.perm.pval.adj, list(true.sup.g1, true.sup.g2), c(903, 97))



```



# Marker analysis
for individual "689_690"
```{r}
library(limma)
#install.packages('org.Hs.eg.db_3.12.0.tar.gz', 
#                 lib = "/Users/MelodyJin/Desktop/MAST90108/MDSresearchproject", 
#                 repo = NULL) 
#library(org.Hs.eg.db, lib.loc = "/Users/MelodyJin/Desktop/MAST90108/MDSresearchproject")
#ann <- AnnotationDbi:::select(org.Hs.eg.db,keys=rownames(pbmc),
#                              columns=c("SYMBOL","ENTREZID","GENENAME"),
#                              keytype = "SYMBOL")
#m <- match(rownames(cm),ann$SYMBOL)
#ann <- ann[m,]
cm<-pbmc@assays$RNA@counts
ann.all<- readRDS("allpbmc.Rds")
numzero.genes <- rowSums(cm==0)
keep.genes <- numzero.genes < (ncol(cm)-10)
all.keep <- cm[keep.genes,]
ann.keep.all <- ann.all[keep.genes,]
cm.processed<- all.keep
table(pbmc.data[, colnames(all.keep)]$predicted.celltype.l1)
logcounts.all <- lognormCounts(all.keep,log=TRUE,prior.count=0.5) 
# permutate all.bct 

all.bct <- factor(pbmc.data[,colnames(pbmc)]$predicted.celltype.l1)
design <- model.matrix(~0+all.bct)
colnames(design)[1:(length(levels(all.bct)))] <- levels(all.bct)

mycont <- matrix(0,ncol=length(levels(all.bct)),nrow=length(levels(all.bct)))
colnames(mycont)<-levels(all.bct)
diag(mycont)<-1
mycont[upper.tri(mycont)]<- -1/(length(levels(all.bct))-1)
mycont[lower.tri(mycont)]<- -1/(length(levels(all.bct))-1)


# Fill out remaining rows with 0s
zero.rows <- matrix(0,ncol=length(levels(all.bct)),nrow=(ncol(design)-length(levels(all.bct))))
test <- rbind(mycont,zero.rows)

fit.obs <- lmFit(logcounts.all,design)
fit.contrast <- contrasts.fit(fit.obs,contrasts=test)

fit.cont.eb.obs <- eBayes(fit.contrast,trend=TRUE,robust=TRUE)

fit.cont.eb.obs$genes <- ann.keep.all
#summa.fit <- decideTests(fit.cont.eb.obs)
#summary(summa.fit)

obs.modtstat<- fit.cont.eb.obs$t


names(fit.contrast)

ordinary.t<- fit.contrast$coef/ fit.contrast$stdev.unscaled / fit.contrast$sigma
obs.tstat<- ordinary.t
obs.t.pval<-pt(ordinary.t, df=fit.contrast$df.residual, lower.tail=FALSE)

obs.mod.pval<- pt(obs.modtstat, df=fit.cont.eb.obs$df.total, lower.tail=FALSE)
#obs.res<-topTable(fit.cont.eb.obs, coef=1, sort="none",number = nrow(fit.cont.eb.obs))$t
#for (i in 2:8){
#  obs.res <- cbind(obs.res, topTable(fit.cont.eb.obs, coef=i, sort="none", number = nrow(fit.cont.eb.obs))$t)
#}
#table(obs.modtstat==obs.res)
#TRUE 
#85432 

#obs.mod.pval2s <-topTable(fit.cont.eb.obs, coef=1, sort="none",number = nrow(fit.cont.eb.obs))$adj.P.Val
#for (i in 2:8){
#  obs.mod.pval2s <- cbind(obs.mod.pval2s, topTable(fit.cont.eb.obs, coef=i, sort="none", number = #nrow(fit.cont.eb.obs))$adj.P.Val)
#}
#table(obs.modtstat==obs.res)
#TRUE 
#85432 

#rownames(obs.mod.pval2s) <- row.names(fit.cont.eb.obs)
#colnames(obs.mod.pval2s) <- colnames(fit.cont.eb.obs)

#plot(obs.mod.pval2s[,1],obs.mod.pval.adj[,1] )

# treat.all$p.value
perm.size<- 1000
modt.perm.array<- readRDS("modt_perm_array_ind1.Rds")
t.perm.array<- readRDS("t_perm_array_ind1.Rds")

obs.mod.pval.adj<- cbind(p.adjust(obs.mod.pval[,1], method="BH"),
                     p.adjust(obs.mod.pval[,2], method="BH"),
                     p.adjust(obs.mod.pval[,3], method="BH"),
                     p.adjust(obs.mod.pval[,4], method="BH"),
                     p.adjust(obs.mod.pval[,5], method="BH"),
                     p.adjust(obs.mod.pval[,6], method="BH"),
                     p.adjust(obs.mod.pval[,7], method="BH"),
                     p.adjust(obs.mod.pval[,8], method="BH"))

obs.t.pval.adj<- cbind(p.adjust(obs.t.pval[,1], method="BH"),
                     p.adjust(obs.t.pval[,2], method="BH"),
                     p.adjust(obs.t.pval[,3], method="BH"),
                     p.adjust(obs.t.pval[,4], method="BH"),
                     p.adjust(obs.t.pval[,5], method="BH"),
                     p.adjust(obs.t.pval[,6], method="BH"),
                     p.adjust(obs.t.pval[,7], method="BH"),
                     p.adjust(obs.t.pval[,8], method="BH"))


modt.perm.array<- array(0, dim = c(dim(logcounts.all)[1], dim(design)[2], perm.size))
t.perm.array<- array(0, dim = c(dim(logcounts.all)[1], dim(design)[2], perm.size))
tic.clearlog()
tic("1000 perm total")
for (i in 1:perm.size) {
  print(i)
  # permutate the all.bct only 
  all.bct.shuffled <- sample(all.bct, replace = FALSE, size =length(all.bct))
  # to do marker analysis using Limma way
  design <- model.matrix(~0+all.bct.shuffled)
  colnames(design)[1:(length(levels(all.bct.shuffled)))] <- levels(all.bct.shuffled)
  mycont <- matrix(0,
                   ncol=length(levels(all.bct.shuffled)),
                   nrow=length(levels(all.bct.shuffled)))
  
  colnames(mycont)<-levels(all.bct.shuffled)
  diag(mycont)<-1
  mycont[upper.tri(mycont)]<- -1/(length(levels(all.bct.shuffled))-1)
  mycont[lower.tri(mycont)]<- -1/(length(levels(all.bct.shuffled))-1)
  
  # Fill out remaining rows with 0s
  zero.rows <- matrix(0,ncol=length(levels(all.bct.shuffled)),
                      nrow=(ncol(design)-length(levels(all.bct.shuffled))))
  
  test <- rbind(mycont, zero.rows)
  tic("lmFit")
  fit <- lmFit(logcounts.all,design)
  toc(log=TRUE)
  tic("contrasts.fit")
  fit.cont <- contrasts.fit(fit, contrasts=test)
  toc(log=TRUE)
  t.perm.array[,,i]<-fit.cont$coef/ fit.cont$stdev.unscaled / fit.cont$sigma
  tic("eBayes")
  fit.cont.eb <- eBayes(fit.cont,trend=TRUE,robust=TRUE)
  toc(log=TRUE)
  fit.cont$genes <- ann.keep.all
  # store the statistic for current permutation 
  modt.perm.array[,,i]<- fit.cont.eb$t
  
}
toc(log=TRUE)
#saveRDS(modt.perm.array, "modt_perm_array_ind1.Rds")
#saveRDS(t.perm.array, "t_perm_array_ind1.Rds")
##########
# modt-stat
modt.perm.pvals<-apply(expand.grid(x = 1:dim(logcounts.all)[1], 
                           y = 1:dim(design)[2]), 1, 
                function(r) (sum(modt.perm.array[r[1],r[2], ]> obs.modtstat[r[1],r[2]]
                                 )+1)/(perm.size+1) )

(modt.perm.pval<- matrix(modt.perm.pvals, 
                  nrow=dim(logcounts.all)[1], 
                  ncol = dim(design)[2], 
                   byrow=FALSE))
rownames(modt.perm.pval) <- row.names(fit.cont.eb.obs)
colnames(modt.perm.pval) <- colnames(fit.cont.eb.obs)

#modt.perm.pvals2s<-apply(expand.grid(x = 1:dim(logcounts.all)[1], 
#                           y = 1:dim(design)[2]), 1, 
#                function(r) (sum(abs(modt.perm.array[r[1],r[2], ])> abs(obs.modtstat[r[1],r[2]]))+1)/(perm.size+1) )
#modt.perm.pval2s<- matrix(modt.perm.pvals2s, 
#                  nrow=dim(logcounts.all)[1], 
#                  ncol = dim(design)[2], 
#                   byrow=FALSE)
#rownames(modt.perm.pval2s) <- row.names(fit.cont.eb.obs)
#colnames(modt.perm.pval2s) <- colnames(fit.cont.eb.obs)

#modt.perm.pval2s.adj<- cbind(p.adjust(modt.perm.pval2s[,1], method="BH"),
#                     p.adjust(modt.perm.pval2s[,2], method="BH"),
#                     p.adjust(modt.perm.pval2s[,3], method="BH"),
#                     p.adjust(modt.perm.pval2s[,4], method="BH"),
#                     p.adjust(modt.perm.pval2s[,5], method="BH"),
#                     p.adjust(modt.perm.pval2s[,6], method="BH"),
#                     p.adjust(modt.perm.pval2s[,7], method="BH"),
#                     p.adjust(modt.perm.pval2s[,8], method="BH"))

#rownames(modt.perm.pval2s.adj) <- row.names(fit.cont.eb.obs)
#colnames(modt.perm.pval2s.adj) <- colnames(fit.cont.eb.obs)


modt.perm.pval.adj<- cbind(p.adjust(modt.perm.pval[,1], method="BH"),
                     p.adjust(modt.perm.pval[,2], method="BH"),
                     p.adjust(modt.perm.pval[,3], method="BH"),
                     p.adjust(modt.perm.pval[,4], method="BH"),
                     p.adjust(modt.perm.pval[,5], method="BH"),
                     p.adjust(modt.perm.pval[,6], method="BH"),
                     p.adjust(modt.perm.pval[,7], method="BH"),
                     p.adjust(modt.perm.pval[,8], method="BH"))

rownames(modt.perm.pval.adj) <- row.names(fit.cont.eb.obs)
colnames(modt.perm.pval.adj) <- colnames(fit.cont.eb.obs)

##########
# t-stat
t.perm.pvals<-apply(expand.grid(x = 1:dim(logcounts.all)[1], 
                           y = 1:dim(design)[2]), 1, 
                function(r) (sum(t.perm.array[r[1],r[2], ]> obs.tstat[r[1],r[2]])+1)/(perm.size+1) )

(t.perm.pval<- matrix(t.perm.pvals, 
                  nrow=dim(logcounts.all)[1], 
                  ncol = dim(design)[2], 
                   byrow=FALSE))
rownames(t.perm.pval) <- row.names(fit.cont.eb.obs)
colnames(t.perm.pval) <- colnames(fit.cont.eb.obs)


t.perm.pval.adj<- cbind(p.adjust(t.perm.pval[,1], method="BH"),
                     p.adjust(t.perm.pval[,2], method="BH"),
                     p.adjust(t.perm.pval[,3], method="BH"),
                     p.adjust(t.perm.pval[,4], method="BH"),
                     p.adjust(t.perm.pval[,5], method="BH"),
                     p.adjust(t.perm.pval[,6], method="BH"),
                     p.adjust(t.perm.pval[,7], method="BH"),
                     p.adjust(t.perm.pval[,8], method="BH"))

rownames(t.perm.pval.adj) <- row.names(fit.cont.eb.obs)
colnames(t.perm.pval.adj) <- colnames(fit.cont.eb.obs)


for (i in 1:8){
  pdf(paste("hist_obs.t.pval.adj_ind1",i,"pdf", sep="."))
  hist(obs.t.pval.adj[,i],
       main = paste("p-values by limma", "-", colnames(obs.t.pval)[i],"cells"), 
       xlab  ="adjusted p-values (t)",
       ylim=c(0, 1500))
  dev.off()
}

for (i in 1:8){
  pdf(paste("hist_t.perm.pval.adj_ind1",i,"pdf", sep="."))
  hist(t.perm.pval.adj[,i],
       main = paste("p-values by permutation", "-", colnames(obs.t.pval)[i],"cells"), 
       xlab  ="adjusted p-values (t)",
       ylim=c(0, 1500))
  dev.off()
}



pdf("hist_ind1.pdf")
hist(obs.t.pval,main = "p-values by limma", xlab  ="p-values (t)" )
hist(obs.t.pval.adj,main = "adjusted p-values by limma", xlab  ="adjusted p-values (t)" )
hist(t.perm.pval,main = "p-values by permutation", xlab  ="p-values (t)" )
hist(t.perm.pval.adj,main = "Adjusted p-values by permutation", xlab  ="adjusted p-values (t)" )

hist(obs.mod.pval,main = "p-values by limma", xlab  ="p-values (moderated t)" )
hist(obs.mod.pval.adj,main = "adjusted p-values by limma", xlab  ="adjusted p-values (moderated t)" )
hist(modt.perm.pval,main = "p-values by permutation", xlab  ="p-values (moderated t)" )
hist(modt.perm.pval.adj,main = "Adjusted p-values by permutation", xlab  ="adjusted p-values (moderated t)" )
dev.off()

library(ggvenn)
for (i in 1:8){
  #df.upreg.genes<- list("limma" = row.names(obs.adj.pval[which(obs.adj.pval[,i]<0.05),]),
   #                     "permutation" = row.names(perm.pval.right[which(perm.pval.right[,i]<0.05),]))
  df.upreg.genes<- list("limma" = row.names(summa.fit[summa.fit[,i]!=0, ]),
                        "permutation" = row.names(perm.pval[which(perm.pval[,i]<0.05),]))
  print("#uppreg genes by limma")
  print(length(df.upreg.genes$limma))
  print("#uppreg genes by permutation")
  print(length(df.upreg.genes$permutation))
  print("# overlapped up-reg genes ")
  print(table(interaction(df.upreg.genes$limma %in% df.upreg.genes$permutation)))
  #ggvenn(
  #  df.upreg.genes, c("limma","permutation"),fill_color = c("blue", "pink"))
  #print("###\n")
}

for (i in 1:8){
  plot(perm.pval[, i],obs.adj.pval[, i], 
       lwd=0.1, pch=".", 
       xlab =("pvalue by permutation"), 
       ylab=("adjusted pvalue by limma"), 
       main=(paste(colnames(perm.pval.adj)[i],"cells")))
  abline(a = 0,b=1, col="blue", lwd = 1.5)
  up_reg_genes =  row.names(summa.fit[summa.fit[,i]==1, ])
  plot(perm.pval[match(up_reg_genes, row.names(perm.pval)), i], 
       obs.adj.pval[match(up_reg_genes, row.names(perm.pval)), i],
       pch="*", 
       xlab =("pvalue by permutation"), 
       ylab=("adjusted pvalue by limma"), col = "orange", 
      main=(paste("significant genes for",colnames(perm.pval)[i],"cells")))
  abline(a = 0,b=1, col="blue", lwd = 1.5)
}

for (i in 1:8){
  pdf(paste("tstat_ind1_p",i,"pdf", sep="."))
  plot(t.perm.pval[, i],obs.t.pval[, i],     
       lwd=0.1, pch=".", 
       xlab =("pvalue by permutation"), 
       ylab=("pvalue by limma"), 
       main=(paste(colnames(modt.perm.pval)[i],"cells")))
  abline(a = 0,b=1, col="blue", lwd = 1.5)
  dev.off()
  up_reg_genes =  row.names(obs.t.pval[which(obs.t.pval[,i]<0.05),])
  pdf(paste("tstat_sig_ind1_p",i,"pdf", sep="."))
  plot(t.perm.pval[match(up_reg_genes, row.names(t.perm.pval)), i], 
       obs.t.pval[match(up_reg_genes, row.names(obs.t.pval)), i],
       pch="*", ylim = c(0,0.05), xlim = c(0,0.05),
       xlab =("pvalue by permutation"), 
       ylab=("pvalue by limma "), col = "orange", 
      main=(paste("significant genes for",colnames(t.perm.pval)[i],"cells")))
  abline(a = 0,b=1, col="blue", lwd = 1.5)
  dev.off()
}

# nclaeese = integer, number of cell types
# all_main = plot title for p-value versus p-value (all genes)
# sig_main = plot title for p-value versus p-value (significant genes from observation <0.05)
# axis_name = specify adjusted p-values or p-values
# perm_p = matrix for pvalues by permutation
# obs_p = matrix for pvalues by limma
save.all.sig.vis<- function(nclasses, all_main, sig_main, perm_p, obs_p, axis_name){
  for (i in 1:nclasses){
    pdf(paste(all_main,i,"pdf", sep="."))
    plot(perm_p[, i],obs_p[, i],     
         lwd=0.1, pch=".", 
         xlab =(paste(axis_name, "by permutation", spe="")), 
         ylab=(paste(axis_name, "by limma", spe="")),
         main=(paste(colnames(perm_p)[i],"cells")))
    abline(a = 0,b=1, col="blue", lwd = 1.5)
    dev.off()
    up_reg_genes =  row.names(obs_p[which(obs_p[,i]<0.05),])
    pdf(paste(sig_main,i,"pdf", sep="."))
    plot(perm_p[match(up_reg_genes, row.names(perm_p)), i], 
         obs_p[match(up_reg_genes, row.names(obs_p)), i],
         pch="*", ylim = c(0,0.05), xlim = c(0,0.05),
         xlab =(paste(axis_name, "by permutation", spe="")), 
         ylab=(paste(axis_name, "by limma", spe="")), col = "orange", 
         main=(paste("significant genes for",colnames(perm_p)[i],"cells")))
    abline(a = 0,b=1, col="blue", lwd = 1.5)
    dev.off()
  }
}

save.all.sig.vis(8, "modtstat_ind1_adjp", "modtstat_sig_ind1_adjp",
                 modt.perm.pval.adj, obs.mod.pval.adj,"adjusted pvalue" )


summa.fit <- decideTests(fit.cont.eb.obs)
summary(summa.fit)

sum_res<- as.data.frame(matrix(NA, nrow =4 , ncol =8 ))
colnames(sum_res)<- colnames(t.perm.pval.adj)
row.names(sum_res)<- c("#cells", "#upregByLimma", "#upregByPermutation","#shared")

print("######## adjusted (one-sided) moderated-t")
for (i in 1:8){
  # p
  #mod_up_reg_genes_limma <- row.names(obs.mod.pval.adj[obs.mod.pval.adj[,i]<0.05,])
  #mod_up_reg_genes_perm<- row.names(modt.perm.pval.adj[modt.perm.pval.adj[,i]<0.05,])
  up_reg_genes_limma <- row.names(obs.t.pval.adj[obs.t.pval.adj[,i]<0.05,])
  up_reg_genes_perm<- row.names(t.perm.pval.adj[t.perm.pval.adj[,i]<0.05,])
  # print(paste("# false positive genes",sum(perm.pval[up_genes, i] >= 0.05)))
  #print(paste("# of up-regulated genes for ", colnames(modt.perm.pval.adj)[i], "cells"))
  print(paste("number of up-regulated genes by limma (t-stat)", length(up_reg_genes_limma)))
  print(paste("number of up-regulated genes by permutation (t-stat)", length(up_reg_genes_perm)))
  print(paste("shared in common:",length(intersect(up_reg_genes_limma, up_reg_genes_perm))))
  print("############")
  
  sum_res[1,i] <- sum(pbmc.data[,colnames(pbmc)]$predicted.celltype.l1 ==colnames(t.perm.pval.adj)[i])
  sum_res[2,i] <- length(up_reg_genes_limma)
  sum_res[3,i] <- length(up_reg_genes_perm)
  sum_res[4,i] <- length(intersect(up_reg_genes_limma, up_reg_genes_perm))
}
sum_res

for (i in 1:8){
  # p
  #mod_up_reg_genes_limma <- row.names(obs.mod.pval.adj[obs.mod.pval.adj[,i]<0.05,])
  #mod_up_reg_genes_perm<- row.names(modt.perm.pval.adj[modt.perm.pval.adj[,i]<0.05,])
  #top_reg_genes_limma <- sort(row.names(obs.t.pval.adj[obs.t.pval.adj[,i]<0.05,], decreasing=FALSE))[1:5]
  #top_reg_genes_perm<- sort(row.names(t.perm.pval.adj[t.perm.pval.adj[,i]<0.05,]), decreasing=FALSE)[1:5]
  up_reg_genes_limma <-row.names(obs.t.pval.adj[obs.t.pval.adj[,i]<0.05,])
  up_reg_genes_perm<- row.names(t.perm.pval.adj[t.perm.pval.adj[,i]<0.05,])
  # print(paste("# false positive genes",sum(perm.pval[up_genes, i] >= 0.05)))
  #print(paste("# of up-regulated genes for ", colnames(modt.perm.pval.adj)[i], "cells"))
  if (length(up_reg_genes_perm)>0){
    boxplot(obs.t.pval.adj[up_reg_genes_limma, ], data = obs.t.pval.adj, 
            main=(paste("regulated genes for",colnames(t.perm.pval.adj)[i],"cells by limma")),
            names = c("B", "CD4 T", "CD8 T", "DC","Mono", "NK", "other", "other T"))
    abline(h=0.05, lty=2, col = "red", lwd = 2)
    boxplot(t.perm.pval.adj[up_reg_genes_perm, ], data = t.perm.pval.adj,
            main=(paste("up-regulated genes for",colnames(t.perm.pval.adj)[i],"cells by permutation")),
            names = c("B", "CD4 T", "CD8 T", "DC","Mono", "NK", "other", "other T"))
    abline(h=0.05, lty=2, col = "red", lwd = 2)
  }
  
}

```

using t-statistic instead 
```{r}
library(limma)
library(tictoc)
cm<-pbmc@assays$RNA@counts
ann.all<- readRDS("allpbmc.Rds")
numzero.genes <- rowSums(cm==0)
keep.genes <- numzero.genes < (ncol(cm)-10)
all.keep <- cm[keep.genes,]
ann.keep.all <- ann.all[keep.genes,]
logcounts.all <- lognormCounts(all.keep,log=TRUE,prior.count=0.5) 

all.bct <- factor(pbmc.data[,colnames(pbmc)]$predicted.celltype.l1)
design.obs <- model.matrix(~0+all.bct)
colnames(design.obs)[1:(length(levels(all.bct)))] <- levels(all.bct)

mycont.obs <- matrix(0,ncol=length(levels(all.bct)),nrow=length(levels(all.bct)))
colnames(mycont.obs)<-levels(all.bct)
diag(mycont.obs)<-1
mycont.obs[upper.tri(mycont.obs)]<- -1/(length(levels(all.bct))-1)
mycont.obs[lower.tri(mycont.obs)]<- -1/(length(levels(all.bct))-1)


# Fill out remaining rows with 0s
zero.rows <- matrix(0,ncol=length(levels(all.bct)),
                    nrow=(ncol(design.obs)-length(levels(all.bct))))
test.obs <- rbind(mycont.obs,zero.rows)
tic("lmFit")
fit.obs <- lmFit(logcounts.all,design.obs)
toc()
tic("contrasts.fit")
fit.cont.obs <- contrasts.fit(fit.obs,contrasts=test.obs)
toc()
#fit.cont.obs$genes <- ann.keep.all

fit.cont.ebays.obs <- eBayes(fit.cont.obs,trend=TRUE,robust=TRUE)

fit.cont.ebays.obs$genes <- ann.keep.all
obs.modtstat<- fit.cont.ebays.obs$t

ordinary.t<- fit.cont.obs$coef/ fit.cont.obs$stdev.unscaled / fit.cont.obs$sigma
obs.tstat<- ordinary.t
obs.pval<-pt(ordinary.t, df=fit.cont.obs$df.residual, lower.tail=FALSE)
obs.pval.adj<- cbind(p.adjust(obs.pval[,1], method="BH"),
                     p.adjust(obs.pval[,2], method="BH"),
                     p.adjust(obs.pval[,3], method="BH"),
                     p.adjust(obs.pval[,4], method="BH"),
                     p.adjust(obs.pval[,5], method="BH"),
                     p.adjust(obs.pval[,6], method="BH"),
                     p.adjust(obs.pval[,7], method="BH"),
                     p.adjust(obs.pval[,8], method="BH"))
for (i in 1:8){
  plot(obs.tstat[,i],obs.modtstat[,i] )
}

perm.size<- 1000
mg.perm.array<- array(0, 
                      dim = c(dim(logcounts.all)[1], dim(design.obs)[2], perm.size))
tic("1000-permutation t-stat total")
for (i in 1:perm.size) {
  print(i)
  # permutate the all.bct only 
  all.bct.shuffled <- sample(all.bct, replace = FALSE, size =length(all.bct))
  # to do marker analysis using Limma way
  design <- model.matrix(~0+all.bct.shuffled)
  colnames(design)[1:(length(levels(all.bct.shuffled)))] <- levels(all.bct.shuffled)
  mycont <- matrix(0,
                   ncol=length(levels(all.bct.shuffled)),
                   nrow=length(levels(all.bct.shuffled)))
  colnames(mycont)<-levels(all.bct.shuffled)
  diag(mycont)<-1
  mycont[upper.tri(mycont)]<- -1/(length(levels(all.bct.shuffled))-1)
  mycont[lower.tri(mycont)]<- -1/(length(levels(all.bct.shuffled))-1)
  
  # Fill out remaining rows with 0s
  zero.rows <- matrix(0,ncol=length(levels(all.bct.shuffled)),
                      nrow=(ncol(design)-length(levels(all.bct.shuffled))))
  test <- rbind(mycont, zero.rows)
  tic("lmFit")
  fit <- lmFit(logcounts.all,design)
  toc()
  tic("contrasts.fit")
  fit.cont <- contrasts.fit(fit, contrasts=test)
  toc()
  fit.cont$genes <- ann.keep.all
  mg.perm.array[,,i]<- fit.cont$coef/ fit.cont$stdev.unscaled / fit.cont$sigma
}
toc()
#mg.perm.array<- readRDS("mg_perm_array_t3_tsta.Rds")

#saveRDS(mg.perm.array, "mg_perm_array_ind1_tstat_fitcont.Rds")
# writeLines(unlist(log.txt), "log_file_1000_ind1.txt")
perm.pvals<-apply(expand.grid(x = 1:dim(logcounts.all)[1], 
                           y = 1:dim(design.obs)[2]), 1, 
                function(r) (sum(mg.perm.array[r[1],r[2], ]>obs.tstat[r[1],r[2]])+1)/(perm.size+1))

(perm.pval<- matrix(perm.pvals, nrow=dim(logcounts.all)[1], 
                  ncol = dim(design.obs)[2], 
                   byrow=FALSE))
row.names(perm.pval) <- row.names(fit.cont.obs)
colnames(perm.pval) <- colnames(fit.cont.obs)

perm.pval.adj<- cbind(p.adjust(perm.pval[,1], method="BH"),
                     p.adjust(perm.pval[,2], method="BH"),
                     p.adjust(perm.pval[,3], method="BH"),
                     p.adjust(perm.pval[,4], method="BH"),
                     p.adjust(perm.pval[,5], method="BH"),
                     p.adjust(perm.pval[,6], method="BH"),
                     p.adjust(perm.pval[,7], method="BH"),
                     p.adjust(perm.pval[,8], method="BH"))

row.names(perm.pval.adj) <- row.names(fit.cont.obs)
colnames(perm.pval.adj) <- colnames(fit.cont.obs)

# distribution of pvalues 
for (i in 1:8){
  hist(obs.pval[,i],ylim = c(0, 500), 
     main = "p-alues by limma", 
     xlab  ="p-alues" )
}
pdf("hist_ind1.pdf")
hist(obs.pval,
     main = "p-alues by limma", 
     xlab  =" p-alues" )
hist(obs.pval.adj,
     main = "Adjusted p-alues by limma", 
     xlab  ="Adjusted p-alues" )
hist(perm.pval.adj,ylim = c(0, 30000), 
     main = "Adjusted p-alues by permutation", 
     xlab  ="Adjusted p-alues" )
hist(perm.pval,ylim = c(0, 30000), 
     main = "p-alues by permutation", 
     xlab  ="p-alues" )
dev.off()
for (i in 1:8){
  pdf(paste("tstat_ind1_adjp",i,"pdf", sep="."))
  plot(obs.pval.adj[, i],perm.pval.adj[, i], 
       lwd=0.1, pch=".", 
       xlab =("adjusted pvalue by permutation"), 
       ylab="adjusted pvalue by limma", main=(paste(colnames(perm.pval)[i],"cells")))
  abline(a = 0,b=1, col="blue", lwd = 1.5)
  dev.off()
}


for (i in 1:8){
  pdf(paste("tstat_ind1",i,"pdf", sep="."))
  #x =  row.names(summa.fit[summa.fit[,i]==1, ])
  plot(obs.pval[, i],perm.pval[, i], 
       lwd=0.1, pch=".", 
       xlab =("pvalue by permutation"), 
       ylab="pvalue by limma", main=(paste(colnames(perm.pval)[i],"cells")))
  abline(a = 0,b=1, col="blue", lwd = 1.5)
  dev.off() 
}

```










```{r}
library(scuttle)
library(scran)

# Directional and with a minimum log-fold change:
obs.wstat <- pairwiseWilcox(logcounts.all,
                      groups=factor(pbmc.data[,colnames(pbmc)]$predicted.celltype.l1),
                      #gene.names = row.names(cm[keep.genes,]), 
                      restrict = factor(c(0,1,1,1,1,1,1,1)))
obs.wstat$pairs
```


```{r}
par(mfrow=c(3,3))
par(mar=c(5,5,2,2))
for(i in 1:ncol(treat.all)){
  plotMD(treat.all,coef=i,status = dt[,i],hl.cex=0.5)
  abline(h=0,col=colours()[c(226)])
  lines(lowess(treat.all$Amean,treat.all$coefficients[,i]),lwd=1.5,col=4)
}
```




```{r}
volcanoplot(fit.cont,coef=2,highlight=100,names=fit.cont$genes)
```


# Gene set testing
```{r}
library(edgeR)
#download.file("http://bioinf.wehi.edu.au/software/MSigDB/human_c2_v5p2.rdata", "human_c2_v5p2.rdata", mode = "wb")
#load("human_c2_v5p2.rdata")
#c2.id <- ids2indices(Hs.c2,treat.all$genes$ENTREZID)

go.terms <- readRDS(url("http://bioinf.wehi.edu.au/MSigDB/v7.1/Hs.c5.all.v7.1.entrez.rds"))
go.terms[1]

go.id <- ids2indices(go.terms,treat.all$genes$ENTREZID)
go.camera <- cameraPR(treat.all$t[,1],go.id)

head(go.camera)
go.camera.up <- go.camera[go.camera[,2]=="Up",]

go.camera.up[1:20,]

reactome.id <-c2.id[grep("REACTOME",names(c2.id))]
cardio.camera <- cameraPR(treat.all$t[,2],reactome.id)
cardio.camera
cardio.camera.up <- cardio.camera[cardio.camera[,2]=="Up",]
colnames(cardio.camera.up)
head(cardio.camera.up)

```




```{r}
library(BioQC)
wilcoxU <- wmwTest(pvals, geneSets, valType = "U", simplify = F)
```

```{r}
head(fit.cont$coefficients)
```

```{r}
barcodeplot(fit.cont$coeff[,1], index=c2.id[["REACTOME_PEPTIDE_CHAIN_ELONGATION"]], main="LogFC: REACTOME_PEPTIDE_CHAIN_ELONGATION")
```

```{r}
barcodeplot(fit.cont$t[,1], index=c2.id[["REACTOME_PEPTIDE_CHAIN_ELONGATION"]], 
            main="LogFC: REACTOME_PEPTIDE_CHAIN_ELONGATION")
```

